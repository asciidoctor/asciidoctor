= Register Processors

In order to use a processor extension it must be registered with a Registry instance.
There are many paths to doing this, the choice depending on how much control you need of which extensions are used on a particular document and how much configuration your extensions need.

== Adding processors to a Registry

Processors are added to a Registry by calling a registry method named after the type of processor.
For instance, to add a block macro, call `registry.block_macro ...`.
The registration method names are specified on the processor-specific pages.
In all cases, the processor is wrapped in a ProcessorExtension.

There are three choices for calling these methods:

With a block::
* The block is always the final argument.
* An optional preceding argument is configuration for the processor.
* If configuration is supplied, a syntax processor may also specify the name as the first argument.

With a class::
* The class or class name is always the first argument.
* An optional last argument is configuration.
* For syntax processors, if configuration is supplied, an optional middle argument is the name of the processor.
Alternatively the name may be specified in the configuration.

With an instance::
* The instance is always the first argument.
* An optional last argument is configuration.
* For syntax processors, if configuration is supplied, an optional middle argument is the name of the processor.
Alternatively the name may be specified in the configuration.

== Using a registry

The most direct method is to explicity create a Registry instance using `Asciidoctor::Extensions.create` or `Asciidoctor::Extensions::Registry.new`, directly add processors to that instance, and supply the instance to a document as `extension_registry: my_registry`.
For instance:

[source,ruby]
----
      registry = Asciidoctor::Extensions.create
      registry.tree_processor SampleTreeProcessor # We are supplying a processor class
      doc = Asciidoctor::Document.new %(= Document Title\n\ncontent).lines, extension_registry: registry
----

=== Groups

More usually registration code is organized into one or more `Group` instances.
There are three choices for a group:

Code block::
The block will be called by a Registry at an appropriate time to inform the Registry of the processors.
Note that if the block takes either no parameters or a single block parameter, i.e. the `arity` is 0 or -1, the registry will use `instance_exec` to call the block, so the Registry methods such as `inline_macro` are available directly in the block.
Otherwise, the block must take one parameter, the Registry instance, and it must call the methods on that instance.

Subclass of Asciidoctor::Extensions::Group::
The subclass must implement an `activate` method taking the Registry as sole parameter.

Instance of a Group subclass::
This provides an opportunity to configure the group.

The `Extensions` module/object tracks globally registered groups.
To globally register a group, call the `Extensions.register` method with the group (or subclass name).
As an optional first argument you may supply a name; these names are currently unused.
Any Registry will include the processors registered by these global groups.
The Group class has a class method `register` that delegates to this `Extensions.register` method.

In addition, it is possible to register a group with a particular Registry instance.
As with the global groups, groups are held in a hash, indexed with a currently unused name.

Groups hash as a constructor argument::
A `groups` hash may be supplied as an optional direct constructor argument: `Asciidoctor::Extensions::Registry.new groups`.
In this case names are required for each group.

Single group as a `create` argument::
A single group, preceded with an optional name, may be supplied when constructing a Registry using the `Asciidoctor.Extensions.create` factory method.
For instance, `Asciidoctor.Extensions.create 'meaningless-name' MyGroup`.

With a pre-existing Registry::
After a Registry is constructed, the groups hash may be accessed and added to.
For instance,

[source,ruby]
----
registry = Extensions.create
registry.groups << 'meaningless': MyGroup
----

== Example

Here is an example of registering many processors in a block Group.
Since the block has no parameters, the methods and attributes of the Registry involved are directly available.
In particular the Document being processed is available as `@document`.
[source,ruby]
----
Asciidoctor::Extensions.register do
  preprocessor FrontMatterPreprocessor
  tree_processor ShellSessionTreeProcessor
  postprocessor CopyrightFooterPostprocessor
  docinfo_processor TrackingCodeDocinfoProcessor if @document.basebackend? 'html'
  block ShoutBlock
  block_macro GistBlockMacro if @document.basebackend? 'html'
  inline_macro ManInlineMacro
  include_processor UriIncludeProcessor
end
----

NOTE: The following commented out statement appears to be false.
See nestable-extension-class.rb
//CAUTION: Processor classes must be defined outside of the register block.
//Once an processor class is registered, it is frozen, preventing further modification.
//If you define an extension class inside the register block, it will result in an error on subsequent invocations.
//However, processors supplied as code blocks can be defined in the register block.